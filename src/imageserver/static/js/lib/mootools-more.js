/* MooTools: the javascript framework. license: MIT-style license. copyright: Copyright (c) 2006-2017 [Valerio Proietti](https://mootools.net/).
   Web Build: https://mootools.net/more/builder/50d2d80fd02103ba3d4bbe8b98c2e180
   Packager build: More/String.QueryString More/URI More/Element.Measure More/Fx.Elements More/Fx.Scroll More/Fx.Slide More/Sortables More/Request.JSONP More/Assets More/Color More/Mask
   
   matt@quru.com: customised More/Sortables to fix bug with page scroll offsets (see comments)
*/
/*
---

script: More.js

name: More

description: MooTools More

license: MIT-style license

authors:
  - Guillermo Rauch
  - Thomas Aylott
  - Scott Kyle
  - Arian Stolwijk
  - Tim Wienk
  - Christoph Pojer
  - Aaron Newton
  - Jacob Thornton

requires:
  - Core/MooTools

provides: [MooTools.More]

...
*/

MooTools.More = {
    version: '1.6.0',
    build: '45b71db70f879781a7e0b0d3fb3bb1307c2521eb'
};

/*
---

script: Element.Measure.js

name: Element.Measure

description: Extends the Element native object to include methods useful in measuring dimensions.

credits: "Element.measure / .expose methods by Daniel Steigerwald License: MIT-style license. Copyright: Copyright (c) 2008 Daniel Steigerwald, daniel.steigerwald.cz"

license: MIT-style license

authors:
  - Aaron Newton

requires:
  - Core/Element.Style
  - Core/Element.Dimensions
  - MooTools.More

provides: [Element.Measure]

...
*/

(function(){

var getStylesList = function(styles, planes){
    var list = [];
    Object.each(planes, function(directions){
        Object.each(directions, function(edge){
            styles.each(function(style){
                list.push(style + '-' + edge + (style == 'border' ? '-width' : ''));
            });
        });
    });
    return list;
};

var calculateEdgeSize = function(edge, styles){
    var total = 0;
    Object.each(styles, function(value, style){
        if (style.test(edge)) total = total + value.toInt();
    });
    return total;
};

var isVisible = function(el){
    return !!(!el || el.offsetHeight || el.offsetWidth);
};


Element.implement({

    measure: function(fn){
        if (isVisible(this)) return fn.call(this);
        var parent = this.getParent(),
            toMeasure = [];
        while (!isVisible(parent) && parent != document.body){
            toMeasure.push(parent.expose());
            parent = parent.getParent();
        }
        var restore = this.expose(),
            result = fn.call(this);
        restore();
        toMeasure.each(function(restore){
            restore();
        });
        return result;
    },

    expose: function(){
        if (this.getStyle('display') != 'none') return function(){};
        var before = this.style.cssText;
        this.setStyles({
            display: 'block',
            position: 'absolute',
            visibility: 'hidden'
        });
        return function(){
            this.style.cssText = before;
        }.bind(this);
    },

    getDimensions: function(options){
        options = Object.merge({computeSize: false}, options);
        var dim = {x: 0, y: 0};

        var getSize = function(el, options){
            return (options.computeSize) ? el.getComputedSize(options) : el.getSize();
        };

        var parent = this.getParent('body');

        if (parent && this.getStyle('display') == 'none'){
            dim = this.measure(function(){
                return getSize(this, options);
            });
        } else if (parent){
            try { //safari sometimes crashes here, so catch it
                dim = getSize(this, options);
            } catch (e){}
        }

        return Object.append(dim, (dim.x || dim.x === 0) ? {
            width: dim.x,
            height: dim.y
        } : {
            x: dim.width,
            y: dim.height
        });
    },

    getComputedSize: function(options){
        

        options = Object.merge({
            styles: ['padding','border'],
            planes: {
                height: ['top','bottom'],
                width: ['left','right']
            },
            mode: 'both'
        }, options);

        var styles = {},
            size = {width: 0, height: 0},
            dimensions;

        if (options.mode == 'vertical'){
            delete size.width;
            delete options.planes.width;
        } else if (options.mode == 'horizontal'){
            delete size.height;
            delete options.planes.height;
        }

        getStylesList(options.styles, options.planes).each(function(style){
            styles[style] = this.getStyle(style).toInt();
        }, this);

        Object.each(options.planes, function(edges, plane){

            var capitalized = plane.capitalize(),
                style = this.getStyle(plane);

            if (style == 'auto' && !dimensions) dimensions = this.getDimensions();

            style = styles[plane] = (style == 'auto') ? dimensions[plane] : style.toInt();
            size['total' + capitalized] = style;

            edges.each(function(edge){
                var edgesize = calculateEdgeSize(edge, styles);
                size['computed' + edge.capitalize()] = edgesize;
                size['total' + capitalized] += edgesize;
            });

        }, this);

        return Object.append(size, styles);
    }

});

})();

/*
---

script: Drag.js

name: Drag

description: The base Drag Class. Can be used to drag and resize Elements using mouse events.

license: MIT-style license

authors:
  - Valerio Proietti
  - Tom Occhinno
  - Jan Kassens

requires:
  - Core/Events
  - Core/Options
  - Core/Element.Event
  - Core/Element.Style
  - Core/Element.Dimensions
  - MooTools.More

provides: [Drag]
...

*/
(function(){

var Drag = this.Drag = new Class({

    Implements: [Events, Options],

    options: {/*
        onBeforeStart: function(thisElement){},
        onStart: function(thisElement, event){},
        onSnap: function(thisElement){},
        onDrag: function(thisElement, event){},
        onCancel: function(thisElement){},
        onComplete: function(thisElement, event){},*/
        snap: 6,
        unit: 'px',
        grid: false,
        style: true,
        limit: false,
        handle: false,
        invert: false,
        unDraggableTags: ['button', 'input', 'a', 'textarea', 'select', 'option'],
        preventDefault: false,
        stopPropagation: false,
        compensateScroll: false,
        modifiers: {x: 'left', y: 'top'}
    },

    initialize: function(){
        var params = Array.link(arguments, {
            'options': Type.isObject,
            'element': function(obj){
                return obj != null;
            }
        });

        this.element = document.id(params.element);
        this.document = this.element.getDocument();
        this.setOptions(params.options || {});
        var htype = typeOf(this.options.handle);
        this.handles = ((htype == 'array' || htype == 'collection') ? $$(this.options.handle) : document.id(this.options.handle)) || this.element;
        this.mouse = {'now': {}, 'pos': {}};
        this.value = {'start': {}, 'now': {}};
        this.offsetParent = (function(el){
            var offsetParent = el.getOffsetParent();
            var isBody = !offsetParent || (/^(?:body|html)$/i).test(offsetParent.tagName);
            return isBody ? window : document.id(offsetParent);
        })(this.element);
        this.selection = 'selectstart' in document ? 'selectstart' : 'mousedown';

        this.compensateScroll = {start: {}, diff: {}, last: {}};

        if ('ondragstart' in document && !('FileReader' in window) && !Drag.ondragstartFixed){
            document.ondragstart = Function.convert(false);
            Drag.ondragstartFixed = true;
        }

        this.bound = {
            start: this.start.bind(this),
            check: this.check.bind(this),
            drag: this.drag.bind(this),
            stop: this.stop.bind(this),
            cancel: this.cancel.bind(this),
            eventStop: Function.convert(false),
            scrollListener: this.scrollListener.bind(this)
        };
        this.attach();
    },

    attach: function(){
        this.handles.addEvent('mousedown', this.bound.start);
        this.handles.addEvent('touchstart', this.bound.start);
        if (this.options.compensateScroll) this.offsetParent.addEvent('scroll', this.bound.scrollListener);
        return this;
    },

    detach: function(){
        this.handles.removeEvent('mousedown', this.bound.start);
        this.handles.removeEvent('touchstart', this.bound.start);
        if (this.options.compensateScroll) this.offsetParent.removeEvent('scroll', this.bound.scrollListener);
        return this;
    },

    scrollListener: function(){

        if (!this.mouse.start) return;
        var newScrollValue = this.offsetParent.getScroll();

        if (this.element.getStyle('position') == 'absolute'){
            var scrollDiff = this.sumValues(newScrollValue, this.compensateScroll.last, -1);
            this.mouse.now = this.sumValues(this.mouse.now, scrollDiff, 1);
        } else {
            this.compensateScroll.diff = this.sumValues(newScrollValue, this.compensateScroll.start, -1);
        }
        if (this.offsetParent != window) this.compensateScroll.diff = this.sumValues(this.compensateScroll.start, newScrollValue, -1);
        this.compensateScroll.last = newScrollValue;
        this.render(this.options);
    },

    sumValues: function(alpha, beta, op){
        var sum = {}, options = this.options;
        for (var z in options.modifiers){
            if (!options.modifiers[z]) continue;
            sum[z] = alpha[z] + beta[z] * op;
        }
        return sum;
    },

    start: function(event){
        if (this.options.unDraggableTags.contains(event.target.get('tag'))) return;

        var options = this.options;

        if (event.rightClick) return;

        if (options.preventDefault) event.preventDefault();
        if (options.stopPropagation) event.stopPropagation();
        this.compensateScroll.start = this.compensateScroll.last = this.offsetParent.getScroll();
        this.compensateScroll.diff = {x: 0, y: 0};
        this.mouse.start = event.page;
        this.fireEvent('beforeStart', this.element);

        var limit = options.limit;
        this.limit = {x: [], y: []};

        var z, coordinates, offsetParent = this.offsetParent == window ? null : this.offsetParent;
        for (z in options.modifiers){
            if (!options.modifiers[z]) continue;

            var style = this.element.getStyle(options.modifiers[z]);

            // Some browsers (IE and Opera) don't always return pixels.
            if (style && !style.match(/px$/)){
                if (!coordinates) coordinates = this.element.getCoordinates(offsetParent);
                style = coordinates[options.modifiers[z]];
            }

            if (options.style) this.value.now[z] = (style || 0).toInt();
            else this.value.now[z] = this.element[options.modifiers[z]];

            if (options.invert) this.value.now[z] *= -1;

            this.mouse.pos[z] = event.page[z] - this.value.now[z];

            if (limit && limit[z]){
                var i = 2;
                while (i--){
                    var limitZI = limit[z][i];
                    if (limitZI || limitZI === 0) this.limit[z][i] = (typeof limitZI == 'function') ? limitZI() : limitZI;
                }
            }
        }

        if (typeOf(this.options.grid) == 'number') this.options.grid = {
            x: this.options.grid,
            y: this.options.grid
        };

        var events = {
            mousemove: this.bound.check,
            mouseup: this.bound.cancel,
            touchmove: this.bound.check,
            touchend: this.bound.cancel
        };
        events[this.selection] = this.bound.eventStop;
        this.document.addEvents(events);
    },

    check: function(event){
        if (this.options.preventDefault) event.preventDefault();
        var distance = Math.round(Math.sqrt(Math.pow(event.page.x - this.mouse.start.x, 2) + Math.pow(event.page.y - this.mouse.start.y, 2)));
        if (distance > this.options.snap){
            this.cancel();
            this.document.addEvents({
                mousemove: this.bound.drag,
                mouseup: this.bound.stop,
                touchmove: this.bound.drag,
                touchend: this.bound.stop
            });
            this.fireEvent('start', [this.element, event]).fireEvent('snap', this.element);
        }
    },

    drag: function(event){
        var options = this.options;
        if (options.preventDefault) event.preventDefault();
        this.mouse.now = this.sumValues(event.page, this.compensateScroll.diff, -1);

        this.render(options);
        this.fireEvent('drag', [this.element, event]);
    },

    render: function(options){
        for (var z in options.modifiers){
            if (!options.modifiers[z]) continue;
            this.value.now[z] = this.mouse.now[z] - this.mouse.pos[z];

            if (options.invert) this.value.now[z] *= -1;
            if (options.limit && this.limit[z]){
                if ((this.limit[z][1] || this.limit[z][1] === 0) && (this.value.now[z] > this.limit[z][1])){
                    this.value.now[z] = this.limit[z][1];
                } else if ((this.limit[z][0] || this.limit[z][0] === 0) && (this.value.now[z] < this.limit[z][0])){
                    this.value.now[z] = this.limit[z][0];
                }
            }
            if (options.grid[z]) this.value.now[z] -= ((this.value.now[z] - (this.limit[z][0]||0)) % options.grid[z]);
            if (options.style) this.element.setStyle(options.modifiers[z], this.value.now[z] + options.unit);
            else this.element[options.modifiers[z]] = this.value.now[z];
        }
    },

    cancel: function(event){
        this.document.removeEvents({
            mousemove: this.bound.check,
            mouseup: this.bound.cancel,
            touchmove: this.bound.check,
            touchend: this.bound.cancel
        });
        if (event){
            this.document.removeEvent(this.selection, this.bound.eventStop);
            this.fireEvent('cancel', this.element);
        }
    },

    stop: function(event){
        var events = {
            mousemove: this.bound.drag,
            mouseup: this.bound.stop,
            touchmove: this.bound.drag,
            touchend: this.bound.stop
        };
        events[this.selection] = this.bound.eventStop;
        this.document.removeEvents(events);
        this.mouse.start = null;
        if (event) this.fireEvent('complete', [this.element, event]);
    }

});

})();


Element.implement({

    makeResizable: function(options){
        var drag = new Drag(this, Object.merge({
            modifiers: {
                x: 'width',
                y: 'height'
            }
        }, options));

        this.store('resizer', drag);
        return drag.addEvent('drag', function(){
            this.fireEvent('resize', drag);
        }.bind(this));
    }

});

/*
---

script: Drag.Move.js

name: Drag.Move

description: A Drag extension that provides support for the constraining of draggables to containers and droppables.

license: MIT-style license

authors:
  - Valerio Proietti
  - Tom Occhinno
  - Jan Kassens
  - Aaron Newton
  - Scott Kyle

requires:
  - Core/Element.Dimensions
  - Drag

provides: [Drag.Move]

...
*/

Drag.Move = new Class({

    Extends: Drag,

    options: {/*
        onEnter: function(thisElement, overed){},
        onLeave: function(thisElement, overed){},
        onDrop: function(thisElement, overed, event){},*/
        droppables: [],
        container: false,
        precalculate: false,
        includeMargins: true,
        checkDroppables: true
    },

    initialize: function(element, options){
        this.parent(element, options);
        element = this.element;

        this.droppables = $$(this.options.droppables);
        this.setContainer(this.options.container);

        if (this.options.style){
            if (this.options.modifiers.x == 'left' && this.options.modifiers.y == 'top'){
                var parent = element.getOffsetParent(),
                    styles = element.getStyles('left', 'top');
                if (parent && (styles.left == 'auto' || styles.top == 'auto')){
                    element.setPosition(element.getPosition(parent));
                }
            }

            if (element.getStyle('position') == 'static') element.setStyle('position', 'absolute');
        }

        this.addEvent('start', this.checkDroppables, true);
        this.overed = null;
    },

    setContainer: function(container){
        this.container = document.id(container);
        if (this.container && typeOf(this.container) != 'element'){
            this.container = document.id(this.container.getDocument().body);
        }
    },

    start: function(event){
        if (this.container) this.options.limit = this.calculateLimit();

        if (this.options.precalculate){
            this.positions = this.droppables.map(function(el){
                return el.getCoordinates();
            });
        }

        this.parent(event);
    },

    calculateLimit: function(){
        var element = this.element,
            container = this.container,

            offsetParent = document.id(element.getOffsetParent()) || document.body,
            containerCoordinates = container.getCoordinates(offsetParent),
            elementMargin = {},
            elementBorder = {},
            containerMargin = {},
            containerBorder = {},
            offsetParentPadding = {},
            offsetScroll = offsetParent.getScroll();

        ['top', 'right', 'bottom', 'left'].each(function(pad){
            elementMargin[pad] = element.getStyle('margin-' + pad).toInt();
            elementBorder[pad] = element.getStyle('border-' + pad).toInt();
            containerMargin[pad] = container.getStyle('margin-' + pad).toInt();
            containerBorder[pad] = container.getStyle('border-' + pad).toInt();
            offsetParentPadding[pad] = offsetParent.getStyle('padding-' + pad).toInt();
        }, this);

        var width = element.offsetWidth + elementMargin.left + elementMargin.right,
            height = element.offsetHeight + elementMargin.top + elementMargin.bottom,
            left = 0 + offsetScroll.x,
            top = 0 + offsetScroll.y,
            right = containerCoordinates.right - containerBorder.right - width + offsetScroll.x,
            bottom = containerCoordinates.bottom - containerBorder.bottom - height + offsetScroll.y;

        if (this.options.includeMargins){
            left += elementMargin.left;
            top += elementMargin.top;
        } else {
            right += elementMargin.right;
            bottom += elementMargin.bottom;
        }

        if (element.getStyle('position') == 'relative'){
            var coords = element.getCoordinates(offsetParent);
            coords.left -= element.getStyle('left').toInt();
            coords.top -= element.getStyle('top').toInt();

            left -= coords.left;
            top -= coords.top;
            if (container.getStyle('position') != 'relative'){
                left += containerBorder.left;
                top += containerBorder.top;
            }
            right += elementMargin.left - coords.left;
            bottom += elementMargin.top - coords.top;

            if (container != offsetParent){
                left += containerMargin.left + offsetParentPadding.left;
                if (!offsetParentPadding.left && left < 0) left = 0;
                top += offsetParent == document.body ? 0 : containerMargin.top + offsetParentPadding.top;
                if (!offsetParentPadding.top && top < 0) top = 0;
            }
        } else {
            left -= elementMargin.left;
            top -= elementMargin.top;
            if (container != offsetParent){
                left += containerCoordinates.left + containerBorder.left;
                top += containerCoordinates.top + containerBorder.top;
            }
        }

        return {
            x: [left, right],
            y: [top, bottom]
        };
    },

    getDroppableCoordinates: function(element){
        var position = element.getCoordinates();
        if (element.getStyle('position') == 'fixed'){
            var scroll = window.getScroll();
            position.left += scroll.x;
            position.right += scroll.x;
            position.top += scroll.y;
            position.bottom += scroll.y;
        }
        return position;
    },

    checkDroppables: function(){
        var overed = this.droppables.filter(function(el, i){
            el = this.positions ? this.positions[i] : this.getDroppableCoordinates(el);
            var now = this.mouse.now;
            return (now.x > el.left && now.x < el.right && now.y < el.bottom && now.y > el.top);
        }, this).getLast();

        if (this.overed != overed){
            if (this.overed) this.fireEvent('leave', [this.element, this.overed]);
            if (overed) this.fireEvent('enter', [this.element, overed]);
            this.overed = overed;
        }
    },

    drag: function(event){
        this.parent(event);
        if (this.options.checkDroppables && this.droppables.length) this.checkDroppables();
    },

    stop: function(event){
        this.checkDroppables();
        this.fireEvent('drop', [this.element, this.overed, event]);
        this.overed = null;
        return this.parent(event);
    }

});

Element.implement({

    makeDraggable: function(options){
        var drag = new Drag.Move(this, options);
        this.store('dragger', drag);
        return drag;
    }

});

/*
---

script: Sortables.js

name: Sortables

description: Class for creating a drag and drop sorting interface for lists of items.

license: MIT-style license

authors:
  - Tom Occhino

requires:
  - Core/Fx.Morph
  - Drag.Move

provides: [Sortables]

...
*/
(function(){

var Sortables = this.Sortables = new Class({

    Implements: [Events, Options],

    options: {/*
        onSort: function(element, clone){},
        onStart: function(element, clone){},
        onComplete: function(element){},*/
        opacity: 1,
        clone: false,
        revert: false,
        handle: false,
        dragOptions: {},
        unDraggableTags: ['button', 'input', 'a', 'textarea', 'select', 'option']
    },

    initialize: function(lists, options){
        this.setOptions(options);

        this.elements = [];
        this.lists = [];
        this.idle = true;

        this.addLists($$(document.id(lists) || lists));

        if (!this.options.clone) this.options.revert = false;
        if (this.options.revert) this.effect = new Fx.Morph(null, Object.merge({
            duration: 250,
            link: 'cancel'
        }, this.options.revert));
    },

    attach: function(){
        this.addLists(this.lists);
        return this;
    },

    detach: function(){
        this.lists = this.removeLists(this.lists);
        return this;
    },

    addItems: function(){
        Array.flatten(arguments).each(function(element){
            this.elements.push(element);
            var start = element.retrieve('sortables:start', function(event){
                this.start.call(this, event, element);
            }.bind(this));
            (this.options.handle ? element.getElement(this.options.handle) || element : element).addEvent('mousedown', start);
        }, this);
        return this;
    },

    addLists: function(){
        Array.flatten(arguments).each(function(list){
            this.lists.include(list);
            this.addItems(list.getChildren());
        }, this);
        return this;
    },

    removeItems: function(){
        return $$(Array.flatten(arguments).map(function(element){
            this.elements.erase(element);
            var start = element.retrieve('sortables:start');
            (this.options.handle ? element.getElement(this.options.handle) || element : element).removeEvent('mousedown', start);

            return element;
        }, this));
    },

    removeLists: function(){
        return $$(Array.flatten(arguments).map(function(list){
            this.lists.erase(list);
            this.removeItems(list.getChildren());

            return list;
        }, this));
    },

    getDroppableCoordinates: function(element){
        var offsetParent = element.getOffsetParent();
        var position = element.getPosition(offsetParent);
        var scroll = {
            w: window.getScroll(),
            offsetParent: offsetParent.getScroll()
        };
        position.x += scroll.offsetParent.x;
        position.y += scroll.offsetParent.y;

        if (offsetParent.getStyle('position') == 'fixed'){
            position.x -= scroll.w.x;
            position.y -= scroll.w.y;
        }

        return position;
    },

    getClone: function(event, element){
        if (!this.options.clone) return new Element(element.tagName).inject(document.body);
        if (typeOf(this.options.clone) == 'function') return this.options.clone.call(this, event, element, this.list);
        var clone = element.clone(true).setStyles({
            margin: 0,
            position: 'absolute',
            visibility: 'hidden',
            width: element.getStyle('width')
        }).addEvent('mousedown', function(event){
            element.fireEvent('mousedown', event);
        });
        //prevent the duplicated radio inputs from unchecking the real one
        if (clone.get('html').test('radio')){
            clone.getElements('input[type=radio]').each(function(input, i){
                input.set('name', 'clone_' + i);
                if (input.get('checked')) element.getElements('input[type=radio]')[i].set('checked', true);
            });
        }

        // matt@quru.com Swap 1.6.0 "getDroppableCoordinates(...)" code for 1.4.0.1 "getPosition(...)" 
        return clone.inject(this.list).setPosition(this.element.getPosition(this.element.getOffsetParent()));
    },

    getDroppables: function(){
        var droppables = this.list.getChildren().erase(this.clone).erase(this.element);
        if (!this.options.constrain) droppables.append(this.lists).erase(this.list);
        return droppables;
    },

    insert: function(dragging, element){
        var where = 'inside';
        if (this.lists.contains(element)){
            this.list = element;
            this.drag.droppables = this.getDroppables();
        } else {
            where = this.element.getAllPrevious().contains(element) ? 'before' : 'after';
        }
        this.element.inject(element, where);
        this.fireEvent('sort', [this.element, this.clone]);
    },

    start: function(event, element){
        if (
            !this.idle ||
            event.rightClick ||
            (!this.options.handle && this.options.unDraggableTags.contains(event.target.get('tag')))
        ) return;

        this.idle = false;
        this.element = element;
        this.opacity = element.getStyle('opacity');
        this.list = element.getParent();
        this.clone = this.getClone(event, element);

        this.drag = new Drag.Move(this.clone, Object.merge({
            
            droppables: this.getDroppables()
        }, this.options.dragOptions)).addEvents({
            onSnap: function(){
                event.stop();
                this.clone.setStyle('visibility', 'visible');
                this.element.setStyle('opacity', this.options.opacity || 0);
                this.fireEvent('start', [this.element, this.clone]);
            }.bind(this),
            onEnter: this.insert.bind(this),
            onCancel: this.end.bind(this),
            onComplete: this.end.bind(this)
        });

        this.clone.inject(this.element, 'before');
        this.drag.start(event);
    },

    end: function(){
        this.drag.detach();
        this.element.setStyle('opacity', this.opacity);
        var self = this;
        if (this.effect){
            var dim = this.element.getStyles('width', 'height'),
                clone = this.clone,
                // matt@quru.com Swap 1.6.0 "getDroppableCoordinates(...)" code for 1.4.0.1 "getPosition(...)" 
                pos = clone.computePosition(this.element.getPosition(this.clone.getOffsetParent()));

            var destroy = function(){
                this.removeEvent('cancel', destroy);
                clone.destroy();
                self.reset();
            };

            this.effect.element = clone;
            this.effect.start({
                top: pos.top,
                left: pos.left,
                width: dim.width,
                height: dim.height,
                opacity: 0.25
            }).addEvent('cancel', destroy).chain(destroy);
        } else {
            this.clone.destroy();
            self.reset();
        }

    },

    reset: function(){
        this.idle = true;
        this.fireEvent('complete', this.element);
    },

    serialize: function(){
        var params = Array.link(arguments, {
            modifier: Type.isFunction,
            index: function(obj){
                return obj != null;
            }
        });
        var serial = this.lists.map(function(list){
            return list.getChildren().map(params.modifier || function(element){
                return element.get('id');
            }, this);
        }, this);

        var index = params.index;
        if (this.lists.length == 1) index = 0;
        return (index || index === 0) && index >= 0 && index < this.lists.length ? serial[index] : serial;
    }

});

})();

/*
---

script: Class.Binds.js

name: Class.Binds

description: Automagically binds specified methods in a class to the instance of the class.

license: MIT-style license

authors:
  - Aaron Newton

requires:
  - Core/Class
  - MooTools.More

provides: [Class.Binds]

...
*/

Class.Mutators.Binds = function(binds){
    if (!this.prototype.initialize) this.implement('initialize', function(){});
    return Array.convert(binds).concat(this.prototype.Binds || []);
};

Class.Mutators.initialize = function(initialize){
    return function(){
        Array.convert(this.Binds).each(function(name){
            var original = this[name];
            if (original) this[name] = original.bind(this);
        }, this);
        return initialize.apply(this, arguments);
    };
};

/*
---

script: Element.Position.js

name: Element.Position

description: Extends the Element native object to include methods useful positioning elements relative to others.

license: MIT-style license

authors:
  - Aaron Newton
  - Jacob Thornton

requires:
  - Core/Options
  - Core/Element.Dimensions
  - Element.Measure

provides: [Element.Position]

...
*/

(function(original){

var local = Element.Position = {

    options: {/*
        edge: false,
        returnPos: false,
        minimum: {x: 0, y: 0},
        maximum: {x: 0, y: 0},
        relFixedPosition: false,
        ignoreMargins: false,
        ignoreScroll: false,
        allowNegative: false,*/
        relativeTo: document.body,
        position: {
            x: 'center', //left, center, right
            y: 'center' //top, center, bottom
        },
        offset: {x: 0, y: 0}
    },

    getOptions: function(element, options){
        options = Object.merge({}, local.options, options);
        local.setPositionOption(options);
        local.setEdgeOption(options);
        local.setOffsetOption(element, options);
        local.setDimensionsOption(element, options);
        return options;
    },

    setPositionOption: function(options){
        options.position = local.getCoordinateFromValue(options.position);
    },

    setEdgeOption: function(options){
        var edgeOption = local.getCoordinateFromValue(options.edge);
        options.edge = edgeOption ? edgeOption :
            (options.position.x == 'center' && options.position.y == 'center') ? {x: 'center', y: 'center'} :
            {x: 'left', y: 'top'};
    },

    setOffsetOption: function(element, options){
        var parentOffset = {x: 0, y: 0};
        var parentScroll = {x: 0, y: 0};
        var offsetParent = element.measure(function(){
            return document.id(this.getOffsetParent());
        });

        if (!offsetParent || offsetParent == element.getDocument().body) return;

        parentScroll = offsetParent.getScroll();
        parentOffset = offsetParent.measure(function(){
            var position = this.getPosition();
            if (this.getStyle('position') == 'fixed'){
                var scroll = window.getScroll();
                position.x += scroll.x;
                position.y += scroll.y;
            }
            return position;
        });

        options.offset = {
            parentPositioned: offsetParent != document.id(options.relativeTo),
            x: options.offset.x - parentOffset.x + parentScroll.x,
            y: options.offset.y - parentOffset.y + parentScroll.y
        };
    },

    setDimensionsOption: function(element, options){
        options.dimensions = element.getDimensions({
            computeSize: true,
            styles: ['padding', 'border', 'margin']
        });
    },

    getPosition: function(element, options){
        var position = {};
        options = local.getOptions(element, options);
        var relativeTo = document.id(options.relativeTo) || document.body;

        local.setPositionCoordinates(options, position, relativeTo);
        if (options.edge) local.toEdge(position, options);

        var offset = options.offset;
        position.left = ((position.x >= 0 || offset.parentPositioned || options.allowNegative) ? position.x : 0).toInt();
        position.top = ((position.y >= 0 || offset.parentPositioned || options.allowNegative) ? position.y : 0).toInt();

        local.toMinMax(position, options);

        if (options.relFixedPosition || relativeTo.getStyle('position') == 'fixed') local.toRelFixedPosition(relativeTo, position);
        if (options.ignoreScroll) local.toIgnoreScroll(relativeTo, position);
        if (options.ignoreMargins) local.toIgnoreMargins(position, options);

        position.left = Math.ceil(position.left);
        position.top = Math.ceil(position.top);
        delete position.x;
        delete position.y;

        return position;
    },

    setPositionCoordinates: function(options, position, relativeTo){
        var offsetY = options.offset.y,
            offsetX = options.offset.x,
            calc = (relativeTo == document.body) ? window.getScroll() : relativeTo.getPosition(),
            top = calc.y,
            left = calc.x,
            winSize = window.getSize();

        switch (options.position.x){
            case 'left': position.x = left + offsetX; break;
            case 'right': position.x = left + offsetX + relativeTo.offsetWidth; break;
            default: position.x = left + ((relativeTo == document.body ? winSize.x : relativeTo.offsetWidth) / 2) + offsetX; break;
        }

        switch (options.position.y){
            case 'top': position.y = top + offsetY; break;
            case 'bottom': position.y = top + offsetY + relativeTo.offsetHeight; break;
            default: position.y = top + ((relativeTo == document.body ? winSize.y : relativeTo.offsetHeight) / 2) + offsetY; break;
        }
    },

    toMinMax: function(position, options){
        var xy = {left: 'x', top: 'y'}, value;
        ['minimum', 'maximum'].each(function(minmax){
            ['left', 'top'].each(function(lr){
                value = options[minmax] ? options[minmax][xy[lr]] : null;
                if (value != null && ((minmax == 'minimum') ? position[lr] < value : position[lr] > value)) position[lr] = value;
            });
        });
    },

    toRelFixedPosition: function(relativeTo, position){
        var winScroll = window.getScroll();
        position.top += winScroll.y;
        position.left += winScroll.x;
    },

    toIgnoreScroll: function(relativeTo, position){
        var relScroll = relativeTo.getScroll();
        position.top -= relScroll.y;
        position.left -= relScroll.x;
    },

    toIgnoreMargins: function(position, options){
        position.left += options.edge.x == 'right'
            ? options.dimensions['margin-right']
            : (options.edge.x != 'center'
                ? -options.dimensions['margin-left']
                : -options.dimensions['margin-left'] + ((options.dimensions['margin-right'] + options.dimensions['margin-left']) / 2));

        position.top += options.edge.y == 'bottom'
            ? options.dimensions['margin-bottom']
            : (options.edge.y != 'center'
                ? -options.dimensions['margin-top']
                : -options.dimensions['margin-top'] + ((options.dimensions['margin-bottom'] + options.dimensions['margin-top']) / 2));
    },

    toEdge: function(position, options){
        var edgeOffset = {},
            dimensions = options.dimensions,
            edge = options.edge;

        switch (edge.x){
            case 'left': edgeOffset.x = 0; break;
            case 'right': edgeOffset.x = -dimensions.x - dimensions.computedRight - dimensions.computedLeft; break;
            // center
            default: edgeOffset.x = -(Math.round(dimensions.totalWidth / 2)); break;
        }

        switch (edge.y){
            case 'top': edgeOffset.y = 0; break;
            case 'bottom': edgeOffset.y = -dimensions.y - dimensions.computedTop - dimensions.computedBottom; break;
            // center
            default: edgeOffset.y = -(Math.round(dimensions.totalHeight / 2)); break;
        }

        position.x += edgeOffset.x;
        position.y += edgeOffset.y;
    },

    getCoordinateFromValue: function(option){
        if (typeOf(option) != 'string') return option;
        option = option.toLowerCase();

        return {
            x: option.test('left') ? 'left'
                : (option.test('right') ? 'right' : 'center'),
            y: option.test(/upper|top/) ? 'top'
                : (option.test('bottom') ? 'bottom' : 'center')
        };
    }

};

Element.implement({

    position: function(options){
        if (options && (options.x != null || options.y != null)){
            return (original ? original.apply(this, arguments) : this);
        }
        var position = this.setStyle('position', 'absolute').calculatePosition(options);
        return (options && options.returnPos) ? position : this.setStyles(position);
    },

    calculatePosition: function(options){
        return local.getPosition(this, options);
    }

});

})(Element.prototype.position);

/*
---

script: Class.Occlude.js

name: Class.Occlude

description: Prevents a class from being applied to a DOM element twice.

license: MIT-style license.

authors:
  - Aaron Newton

requires:
  - Core/Class
  - Core/Element
  - MooTools.More

provides: [Class.Occlude]

...
*/

Class.Occlude = new Class({

    occlude: function(property, element){
        element = document.id(element || this.element);
        var instance = element.retrieve(property || this.property);
        if (instance && !this.occluded)
            return (this.occluded = instance);

        this.occluded = false;
        element.store(property || this.property, this);
        return this.occluded;
    }

});

/*
---

script: IframeShim.js

name: IframeShim

description: Defines IframeShim, a class for obscuring select lists and flash objects in IE.

license: MIT-style license

authors:
  - Aaron Newton

requires:
  - Core/Element.Event
  - Core/Element.Style
  - Core/Options
  - Core/Events
  - Element.Position
  - Class.Occlude

provides: [IframeShim]

...
*/

(function(){

var browsers = false;


var IframeShim = this.IframeShim = new Class({

    Implements: [Options, Events, Class.Occlude],

    options: {
        className: 'iframeShim',
        src: 'javascript:false;document.write("");',
        display: false,
        zIndex: null,
        margin: 0,
        offset: {x: 0, y: 0},
        browsers: browsers
    },

    property: 'IframeShim',

    initialize: function(element, options){
        this.element = document.id(element);
        if (this.occlude()) return this.occluded;
        this.setOptions(options);
        this.makeShim();
        return this;
    },

    makeShim: function(){
        if (this.options.browsers){
            var zIndex = this.element.getStyle('zIndex').toInt();

            if (!zIndex){
                zIndex = 1;
                var pos = this.element.getStyle('position');
                if (pos == 'static' || !pos) this.element.setStyle('position', 'relative');
                this.element.setStyle('zIndex', zIndex);
            }
            zIndex = ((this.options.zIndex != null || this.options.zIndex === 0) && zIndex > this.options.zIndex) ? this.options.zIndex : zIndex - 1;
            if (zIndex < 0) zIndex = 1;
            this.shim = new Element('iframe', {
                src: this.options.src,
                scrolling: 'no',
                frameborder: 0,
                styles: {
                    zIndex: zIndex,
                    position: 'absolute',
                    border: 'none',
                    filter: 'progid:DXImageTransform.Microsoft.Alpha(style=0,opacity=0)'
                },
                'class': this.options.className
            }).store('IframeShim', this);
            var inject = (function(){
                this.shim.inject(this.element, 'after');
                this[this.options.display ? 'show' : 'hide']();
                this.fireEvent('inject');
            }).bind(this);
            if (!IframeShim.ready) window.addEvent('load', inject);
            else inject();
        } else {
            this.position = this.hide = this.show = this.dispose = Function.convert(this);
        }
    },

    position: function(){
        if (!IframeShim.ready || !this.shim) return this;
        var size = this.element.measure(function(){
            return this.getSize();
        });
        if (this.options.margin != undefined){
            size.x = size.x - (this.options.margin * 2);
            size.y = size.y - (this.options.margin * 2);
            this.options.offset.x += this.options.margin;
            this.options.offset.y += this.options.margin;
        }
        this.shim.set({width: size.x, height: size.y}).position({
            relativeTo: this.element,
            offset: this.options.offset
        });
        return this;
    },

    hide: function(){
        if (this.shim) this.shim.setStyle('display', 'none');
        return this;
    },

    show: function(){
        if (this.shim) this.shim.setStyle('display', 'block');
        return this.position();
    },

    dispose: function(){
        if (this.shim) this.shim.dispose();
        return this;
    },

    destroy: function(){
        if (this.shim) this.shim.destroy();
        return this;
    }

});

})();

window.addEvent('load', function(){
    IframeShim.ready = true;
});

/*
---

script: Mask.js

name: Mask

description: Creates a mask element to cover another.

license: MIT-style license

authors:
  - Aaron Newton

requires:
  - Core/Options
  - Core/Events
  - Core/Element.Event
  - Class.Binds
  - Element.Position
  - IframeShim

provides: [Mask]

...
*/
(function(){

var Mask = this.Mask = new Class({

    Implements: [Options, Events],

    Binds: ['position'],

    options: {/*
        onShow: function(){},
        onHide: function(){},
        onDestroy: function(){},
        onClick: function(event){},
        inject: {
            where: 'after',
            target: null,
        },
        hideOnClick: false,
        id: null,
        destroyOnHide: false,*/
        style: {},
        'class': 'mask',
        maskMargins: false,
        useIframeShim: true,
        iframeShimOptions: {}
    },

    initialize: function(target, options){
        this.target = document.id(target) || document.id(document.body);
        this.target.store('mask', this);
        this.setOptions(options);
        this.render();
        this.inject();
    },

    render: function(){
        this.element = new Element('div', {
            'class': this.options['class'],
            id: this.options.id || 'mask-' + String.uniqueID(),
            styles: Object.merge({}, this.options.style, {
                display: 'none'
            }),
            events: {
                click: function(event){
                    this.fireEvent('click', event);
                    if (this.options.hideOnClick) this.hide();
                }.bind(this)
            }
        });

        this.hidden = true;
    },

    toElement: function(){
        return this.element;
    },

    inject: function(target, where){
        where = where || (this.options.inject ? this.options.inject.where : '') || (this.target == document.body ? 'inside' : 'after');
        target = target || (this.options.inject && this.options.inject.target) || this.target;

        this.element.inject(target, where);

        if (this.options.useIframeShim){
            this.shim = new IframeShim(this.element, this.options.iframeShimOptions);

            this.addEvents({
                show: this.shim.show.bind(this.shim),
                hide: this.shim.hide.bind(this.shim),
                destroy: this.shim.destroy.bind(this.shim)
            });
        }
    },

    position: function(){
        this.resize(this.options.width, this.options.height);

        this.element.position({
            relativeTo: this.target,
            position: 'topLeft',
            ignoreMargins: !this.options.maskMargins,
            ignoreScroll: this.target == document.body
        });

        return this;
    },

    resize: function(x, y){
        var opt = {
            styles: ['padding', 'border']
        };
        if (this.options.maskMargins) opt.styles.push('margin');

        var dim = this.target.getComputedSize(opt);
        if (this.target == document.body){
            this.element.setStyles({width: 0, height: 0});
            var win = window.getScrollSize();
            if (dim.totalHeight < win.y) dim.totalHeight = win.y;
            if (dim.totalWidth < win.x) dim.totalWidth = win.x;
        }
        this.element.setStyles({
            width: Array.pick([x, dim.totalWidth, dim.x]),
            height: Array.pick([y, dim.totalHeight, dim.y])
        });

        return this;
    },

    show: function(){
        if (!this.hidden) return this;

        window.addEvent('resize', this.position);
        this.position();
        this.showMask.apply(this, arguments);

        return this;
    },

    showMask: function(){
        this.element.setStyle('display', 'block');
        this.hidden = false;
        this.fireEvent('show');
    },

    hide: function(){
        if (this.hidden) return this;

        window.removeEvent('resize', this.position);
        this.hideMask.apply(this, arguments);
        if (this.options.destroyOnHide) return this.destroy();

        return this;
    },

    hideMask: function(){
        this.element.setStyle('display', 'none');
        this.hidden = true;
        this.fireEvent('hide');
    },

    toggle: function(){
        this[this.hidden ? 'show' : 'hide']();
    },

    destroy: function(){
        this.hide();
        this.element.destroy();
        this.fireEvent('destroy');
        this.target.eliminate('mask');
    }

});

})();


Element.Properties.mask = {

    set: function(options){
        var mask = this.retrieve('mask');
        if (mask) mask.destroy();
        return this.eliminate('mask').store('mask:options', options);
    },

    get: function(){
        var mask = this.retrieve('mask');
        if (!mask){
            mask = new Mask(this, this.retrieve('mask:options'));
            this.store('mask', mask);
        }
        return mask;
    }

};

Element.implement({

    mask: function(options){
        if (options) this.set('mask', options);
        this.get('mask').show();
        return this;
    },

    unmask: function(){
        this.get('mask').hide();
        return this;
    }

});

/*
---

script: String.QueryString.js

name: String.QueryString

description: Methods for dealing with URI query strings.

license: MIT-style license

authors:
  - Sebastian Markbåge
  - Aaron Newton
  - Lennart Pilon
  - Valerio Proietti

requires:
  - Core/Array
  - Core/String
  - MooTools.More

provides: [String.QueryString]

...
*/

(function(){

/**
 * decodeURIComponent doesn't do the correct thing with query parameter keys or
 * values. Specifically, it leaves '+' as '+' when it should be converting them
 * to spaces as that's the specification. When browsers submit HTML forms via
 * GET, the values are encoded using 'application/x-www-form-urlencoded'
 * which converts spaces to '+'.
 *
 * See: http://unixpapa.com/js/querystring.html for a description of the
 * problem.
 */
var decodeComponent = function(str){
    return decodeURIComponent(str.replace(/\+/g, ' '));
};

String.implement({

    parseQueryString: function(decodeKeys, decodeValues){
        if (decodeKeys == null) decodeKeys = true;
        if (decodeValues == null) decodeValues = true;

        var vars = this.split(/[&;]/),
            object = {};
        if (!vars.length) return object;

        vars.each(function(val){
            var index = val.indexOf('=') + 1,
                value = index ? val.substr(index) : '',
                keys = index ? val.substr(0, index - 1).match(/([^\]\[]+|(\B)(?=\]))/g) : [val],
                obj = object;
            if (!keys) return;
            if (decodeValues) value = decodeComponent(value);
            keys.each(function(key, i){
                if (decodeKeys) key = decodeComponent(key);
                var current = obj[key];

                if (i < keys.length - 1) obj = obj[key] = current || {};
                else if (typeOf(current) == 'array') current.push(value);
                else obj[key] = current != null ? [current, value] : value;
            });
        });

        return object;
    },

    cleanQueryString: function(method){
        return this.split('&').filter(function(val){
            var index = val.indexOf('='),
                key = index < 0 ? '' : val.substr(0, index),
                value = val.substr(index + 1);

            return method ? method.call(null, key, value) : (value || value === 0);
        }).join('&');
    }

});

})();

/*
---

script: Fx.Elements.js

name: Fx.Elements

description: Effect to change any number of CSS properties of any number of Elements.

license: MIT-style license

authors:
  - Valerio Proietti

requires:
  - Core/Fx.CSS
  - MooTools.More

provides: [Fx.Elements]

...
*/

Fx.Elements = new Class({

    Extends: Fx.CSS,

    initialize: function(elements, options){
        this.elements = this.subject = $$(elements);
        this.parent(options);
    },

    compute: function(from, to, delta){
        var now = {};

        for (var i in from){
            var iFrom = from[i], iTo = to[i], iNow = now[i] = {};
            for (var p in iFrom) iNow[p] = this.parent(iFrom[p], iTo[p], delta);
        }

        return now;
    },

    set: function(now){
        for (var i in now){
            if (!this.elements[i]) continue;

            var iNow = now[i];
            for (var p in iNow) this.render(this.elements[i], p, iNow[p], this.options.unit);
        }

        return this;
    },

    start: function(obj){
        if (!this.check(obj)) return this;
        var from = {}, to = {};

        for (var i in obj){
            if (!this.elements[i]) continue;

            var iProps = obj[i], iFrom = from[i] = {}, iTo = to[i] = {};

            for (var p in iProps){
                var parsed = this.prepare(this.elements[i], p, iProps[p]);
                iFrom[p] = parsed.from;
                iTo[p] = parsed.to;
            }
        }

        return this.parent(from, to);
    }

});

/*
---

script: Fx.Scroll.js

name: Fx.Scroll

description: Effect to smoothly scroll any element, including the window.

license: MIT-style license

authors:
  - Valerio Proietti

requires:
  - Core/Fx
  - Core/Element.Event
  - Core/Element.Dimensions
  - MooTools.More

provides: [Fx.Scroll]

...
*/

(function(){

Fx.Scroll = new Class({

    Extends: Fx,

    options: {
        offset: {x: 0, y: 0},
        wheelStops: true
    },

    initialize: function(element, options){
        this.element = this.subject = document.id(element);
        this.parent(options);

        if (typeOf(this.element) != 'element') this.element = document.id(this.element.getDocument().body);

        if (this.options.wheelStops){
            var stopper = this.element,
                cancel = this.cancel.pass(false, this);
            this.addEvent('start', function(){
                stopper.addEvent('mousewheel', cancel);
            }, true);
            this.addEvent('complete', function(){
                stopper.removeEvent('mousewheel', cancel);
            }, true);
        }
    },

    set: function(){
        var now = Array.flatten(arguments);
        this.element.scrollTo(now[0], now[1]);
        return this;
    },

    compute: function(from, to, delta){
        return [0, 1].map(function(i){
            return Fx.compute(from[i], to[i], delta);
        });
    },

    start: function(x, y){
        if (!this.check(x, y)) return this;
        var scroll = this.element.getScroll();
        return this.parent([scroll.x, scroll.y], [x, y]);
    },

    calculateScroll: function(x, y){
        var element = this.element,
            scrollSize = element.getScrollSize(),
            scroll = element.getScroll(),
            size = element.getSize(),
            offset = this.options.offset,
            values = {x: x, y: y};

        for (var z in values){
            if (!values[z] && values[z] !== 0) values[z] = scroll[z];
            if (typeOf(values[z]) != 'number') values[z] = scrollSize[z] - size[z];
            values[z] += offset[z];
        }

        return [values.x, values.y];
    },

    toTop: function(){
        return this.start.apply(this, this.calculateScroll(false, 0));
    },

    toLeft: function(){
        return this.start.apply(this, this.calculateScroll(0, false));
    },

    toRight: function(){
        return this.start.apply(this, this.calculateScroll('right', false));
    },

    toBottom: function(){
        return this.start.apply(this, this.calculateScroll(false, 'bottom'));
    },

    toElement: function(el, axes){
        axes = axes ? Array.convert(axes) : ['x', 'y'];
        var scroll = isBody(this.element) ? {x: 0, y: 0} : this.element.getScroll();
        var position = Object.map(document.id(el).getPosition(this.element), function(value, axis){
            return axes.contains(axis) ? value + scroll[axis] : false;
        });
        return this.start.apply(this, this.calculateScroll(position.x, position.y));
    },

    toElementEdge: function(el, axes, offset){
        axes = axes ? Array.convert(axes) : ['x', 'y'];
        el = document.id(el);
        var to = {},
            position = el.getPosition(this.element),
            size = el.getSize(),
            scroll = this.element.getScroll(),
            containerSize = this.element.getSize(),
            edge = {
                x: position.x + size.x,
                y: position.y + size.y
            };

        ['x', 'y'].each(function(axis){
            if (axes.contains(axis)){
                if (edge[axis] > scroll[axis] + containerSize[axis]) to[axis] = edge[axis] - containerSize[axis];
                if (position[axis] < scroll[axis]) to[axis] = position[axis];
            }
            if (to[axis] == null) to[axis] = scroll[axis];
            if (offset && offset[axis]) to[axis] = to[axis] + offset[axis];
        }, this);

        if (to.x != scroll.x || to.y != scroll.y) this.start(to.x, to.y);
        return this;
    },

    toElementCenter: function(el, axes, offset){
        axes = axes ? Array.convert(axes) : ['x', 'y'];
        el = document.id(el);
        var to = {},
            position = el.getPosition(this.element),
            size = el.getSize(),
            scroll = this.element.getScroll(),
            containerSize = this.element.getSize();

        ['x', 'y'].each(function(axis){
            if (axes.contains(axis)){
                to[axis] = position[axis] - (containerSize[axis] - size[axis]) / 2;
            }
            if (to[axis] == null) to[axis] = scroll[axis];
            if (offset && offset[axis]) to[axis] = to[axis] + offset[axis];
        }, this);

        if (to.x != scroll.x || to.y != scroll.y) this.start(to.x, to.y);
        return this;
    }

});



function isBody(element){
    return (/^(?:body|html)$/i).test(element.tagName);
}

})();

/*
---

script: Fx.Slide.js

name: Fx.Slide

description: Effect to slide an element in and out of view.

license: MIT-style license

authors:
  - Valerio Proietti

requires:
  - Core/Fx
  - Core/Element.Style
  - MooTools.More

provides: [Fx.Slide]

...
*/

Fx.Slide = new Class({

    Extends: Fx,

    options: {
        mode: 'vertical',
        wrapper: false,
        hideOverflow: true,
        resetHeight: false
    },

    initialize: function(element, options){
        element = this.element = this.subject = document.id(element);
        this.parent(options);
        options = this.options;

        var wrapper = element.retrieve('wrapper'),
            styles = element.getStyles('margin', 'position', 'overflow');

        if (options.hideOverflow) styles = Object.append(styles, {overflow: 'hidden'});
        if (options.wrapper) wrapper = document.id(options.wrapper).setStyles(styles);

        if (!wrapper) wrapper = new Element('div', {
            styles: styles
        }).wraps(element);

        element.store('wrapper', wrapper).setStyle('margin', 0);
        if (element.getStyle('overflow') == 'visible') element.setStyle('overflow', 'hidden');

        this.now = [];
        this.open = true;
        this.wrapper = wrapper;

        this.addEvent('complete', function(){
            this.open = (wrapper['offset' + this.layout.capitalize()] != 0);
            if (this.open && this.options.resetHeight) wrapper.setStyle('height', '');
        }, true);
    },

    vertical: function(){
        this.margin = 'margin-top';
        this.layout = 'height';
        this.offset = this.element.offsetHeight;
    },

    horizontal: function(){
        this.margin = 'margin-left';
        this.layout = 'width';
        this.offset = this.element.offsetWidth;
    },

    set: function(now){
        this.element.setStyle(this.margin, now[0]);
        this.wrapper.setStyle(this.layout, now[1]);
        return this;
    },

    compute: function(from, to, delta){
        return [0, 1].map(function(i){
            return Fx.compute(from[i], to[i], delta);
        });
    },

    start: function(how, mode){
        if (!this.check(how, mode)) return this;
        this[mode || this.options.mode]();

        var margin = this.element.getStyle(this.margin).toInt(),
            layout = this.wrapper.getStyle(this.layout).toInt(),
            caseIn = [[margin, layout], [0, this.offset]],
            caseOut = [[margin, layout], [-this.offset, 0]],
            start;

        switch (how){
            case 'in': start = caseIn; break;
            case 'out': start = caseOut; break;
            case 'toggle': start = (layout == 0) ? caseIn : caseOut;
        }
        return this.parent(start[0], start[1]);
    },

    slideIn: function(mode){
        return this.start('in', mode);
    },

    slideOut: function(mode){
        return this.start('out', mode);
    },

    hide: function(mode){
        this[mode || this.options.mode]();
        this.open = false;
        return this.set([-this.offset, 0]);
    },

    show: function(mode){
        this[mode || this.options.mode]();
        this.open = true;
        return this.set([0, this.offset]);
    },

    toggle: function(mode){
        return this.start('toggle', mode);
    }

});

Element.Properties.slide = {

    set: function(options){
        this.get('slide').cancel().setOptions(options);
        return this;
    },

    get: function(){
        var slide = this.retrieve('slide');
        if (!slide){
            slide = new Fx.Slide(this, {link: 'cancel'});
            this.store('slide', slide);
        }
        return slide;
    }

};

Element.implement({

    slide: function(how, mode){
        how = how || 'toggle';
        var slide = this.get('slide'), toggle;
        switch (how){
            case 'hide': slide.hide(mode); break;
            case 'show': slide.show(mode); break;
            case 'toggle':
                var flag = this.retrieve('slide:flag', slide.open);
                slide[flag ? 'slideOut' : 'slideIn'](mode);
                this.store('slide:flag', !flag);
                toggle = true;
                break;
            default: slide.start(how, mode);
        }
        if (!toggle) this.eliminate('slide:flag');
        return this;
    }

});

/*
---

script: Request.JSONP.js

name: Request.JSONP

description: Defines Request.JSONP, a class for cross domain javascript via script injection.

license: MIT-style license

authors:
  - Aaron Newton
  - Guillermo Rauch
  - Arian Stolwijk

requires:
  - Core/Element
  - Core/Request
  - MooTools.More

provides: [Request.JSONP]

...
*/

Request.JSONP = new Class({

    Implements: [Chain, Events, Options],

    options: {/*
        onRequest: function(src, scriptElement){},
        onComplete: function(data){},
        onSuccess: function(data){},
        onCancel: function(){},
        onTimeout: function(){},
        onError: function(){}, */
        onRequest: function(src){
            if (this.options.log && window.console && console.log){
                console.log('JSONP retrieving script with url:' + src);
            }
        },
        onError: function(src){
            if (this.options.log && window.console && console.warn){
                console.warn('JSONP '+ src +' will fail in Internet Explorer, which enforces a 2083 bytes length limit on URIs');
            }
        },
        url: '',
        callbackKey: 'callback',
        injectScript: document.head,
        data: '',
        link: 'ignore',
        timeout: 0,
        log: false
    },

    initialize: function(options){
        this.setOptions(options);
    },

    send: function(options){
        if (!Request.prototype.check.call(this, options)) return this;
        this.running = true;

        var type = typeOf(options);
        if (type == 'string' || type == 'element') options = {data: options};
        options = Object.merge(this.options, options || {});

        var data = options.data;
        switch (typeOf(data)){
            case 'element': data = document.id(data).toQueryString(); break;
            case 'object': case 'hash': data = Object.toQueryString(data);
        }

        var index = this.index = Request.JSONP.counter++,
            key = 'request_' + index;

        var src = options.url +
            (options.url.test('\\?') ? '&' :'?') +
            (options.callbackKey) +
            '=Request.JSONP.request_map.request_'+ index +
            (data ? '&' + data : '');

        if (src.length > 2083) this.fireEvent('error', src);

        Request.JSONP.request_map[key] = function(){
            delete Request.JSONP.request_map[key];
            this.success(arguments, index);
        }.bind(this);

        var script = this.getScript(src).inject(options.injectScript);
        this.fireEvent('request', [src, script]);

        if (options.timeout) this.timeout.delay(options.timeout, this);

        return this;
    },

    getScript: function(src){
        if (!this.script) this.script = new Element('script', {
            type: 'text/javascript',
            async: true,
            src: src
        });
        return this.script;
    },

    success: function(args){
        if (!this.running) return;
        this.clear()
            .fireEvent('complete', args).fireEvent('success', args)
            .callChain();
    },

    cancel: function(){
        if (this.running) this.clear().fireEvent('cancel');
        return this;
    },

    isRunning: function(){
        return !!this.running;
    },

    clear: function(){
        this.running = false;
        if (this.script){
            this.script.destroy();
            this.script = null;
        }
        return this;
    },

    timeout: function(){
        if (this.running){
            this.running = false;
            this.fireEvent('timeout', [this.script.get('src'), this.script]).fireEvent('failure').cancel();
        }
        return this;
    }

});

Request.JSONP.counter = 0;
Request.JSONP.request_map = {};

/*
---

script: URI.js

name: URI

description: Provides methods useful in managing the window location and uris.

license: MIT-style license

authors:
  - Sebastian Markbåge
  - Aaron Newton

requires:
  - Core/Object
  - Core/Class
  - Core/Class.Extras
  - Core/Element
  - String.QueryString

provides: [URI]

...
*/

(function(){

var toString = function(){
    return this.get('value');
};

var URI = this.URI = new Class({

    Implements: Options,

    options: {
        /*base: false*/
    },

    regex: /^(?:(\w+):)?(?:\/\/(?:(?:([^:@\/]*):?([^:@\/]*))?@)?(\[[A-Fa-f0-9:]+\]|[^:\/?#]*)(?::(\d*))?)?(\.\.?$|(?:[^?#\/]*\/)*)([^?#]*)(?:\?([^#]*))?(?:#(.*))?/,
    parts: ['scheme', 'user', 'password', 'host', 'port', 'directory', 'file', 'query', 'fragment'],
    schemes: {http: 80, https: 443, ftp: 21, rtsp: 554, mms: 1755, file: 0},

    initialize: function(uri, options){
        this.setOptions(options);
        var base = this.options.base || URI.base;
        if (!uri) uri = base;

        if (uri && uri.parsed) this.parsed = Object.clone(uri.parsed);
        else this.set('value', uri.href || uri.toString(), base ? new URI(base) : false);
    },

    parse: function(value, base){
        var bits = value.match(this.regex);
        if (!bits) return false;
        bits.shift();
        return this.merge(bits.associate(this.parts), base);
    },

    merge: function(bits, base){
        if ((!bits || !bits.scheme) && (!base || !base.scheme)) return false;
        if (base){
            this.parts.every(function(part){
                if (bits[part]) return false;
                bits[part] = base[part] || '';
                return true;
            });
        }
        bits.port = bits.port || this.schemes[bits.scheme.toLowerCase()];
        bits.directory = bits.directory ? this.parseDirectory(bits.directory, base ? base.directory : '') : '/';
        return bits;
    },

    parseDirectory: function(directory, baseDirectory){
        directory = (directory.substr(0, 1) == '/' ? '' : (baseDirectory || '/')) + directory;
        if (!directory.test(URI.regs.directoryDot)) return directory;
        var result = [];
        directory.replace(URI.regs.endSlash, '').split('/').each(function(dir){
            if (dir == '..' && result.length > 0) result.pop();
            else if (dir != '.') result.push(dir);
        });
        return result.join('/') + '/';
    },

    combine: function(bits){
        return bits.value || bits.scheme + '://' +
            (bits.user ? bits.user + (bits.password ? ':' + bits.password : '') + '@' : '') +
            (bits.host || '') + (bits.port && bits.port != this.schemes[bits.scheme] ? ':' + bits.port : '') +
            (bits.directory || '/') + (bits.file || '') +
            (bits.query ? '?' + bits.query : '') +
            (bits.fragment ? '#' + bits.fragment : '');
    },

    set: function(part, value, base){
        if (part == 'value'){
            var scheme = value.match(URI.regs.scheme);
            if (scheme) scheme = scheme[1];
            if (scheme && this.schemes[scheme.toLowerCase()] == null) this.parsed = { scheme: scheme, value: value };
            else this.parsed = this.parse(value, (base || this).parsed) || (scheme ? { scheme: scheme, value: value } : { value: value });
        } else if (part == 'data'){
            this.setData(value);
        } else {
            this.parsed[part] = value;
        }
        return this;
    },

    get: function(part, base){
        switch (part){
            case 'value': return this.combine(this.parsed, base ? base.parsed : false);
            case 'data' : return this.getData();
        }
        return this.parsed[part] || '';
    },

    go: function(){
        document.location.href = this.toString();
    },

    toURI: function(){
        return this;
    },

    getData: function(key, part){
        var qs = this.get(part || 'query');
        if (!(qs || qs === 0)) return key ? null : {};
        var obj = qs.parseQueryString();
        return key ? obj[key] : obj;
    },

    setData: function(values, merge, part){
        if (typeof values == 'string'){
            var data = this.getData();
            data[arguments[0]] = arguments[1];
            values = data;
        } else if (merge){
            values = Object.merge(this.getData(null, part), values);
        }
        return this.set(part || 'query', Object.toQueryString(values));
    },

    clearData: function(part){
        return this.set(part || 'query', '');
    },

    toString: toString,
    valueOf: toString

});

URI.regs = {
    endSlash: /\/$/,
    scheme: /^(\w+):/,
    directoryDot: /\.\/|\.$/
};

URI.base = new URI(Array.convert(document.getElements('base[href]', true)).getLast(), {base: document.location});

String.implement({

    toURI: function(options){
        return new URI(this, options);
    }

});

})();

/*
---

script: Assets.js

name: Assets

description: Provides methods to dynamically load JavaScript, CSS, and Image files into the document.

license: MIT-style license

authors:
  - Valerio Proietti

requires:
  - Core/Element.Event
  - MooTools.More

provides: [Assets, Asset.javascript, Asset.css, Asset.image, Asset.images]

...
*/
;(function(){

var Asset = this.Asset = {

    javascript: function(source, properties){
        if (!properties) properties = {};

        var script = new Element('script', {src: source, type: 'text/javascript'}),
            doc = properties.document || document,
            load = properties.onload || properties.onLoad;

        delete properties.onload;
        delete properties.onLoad;
        delete properties.document;

        if (load){
            if (!script.addEventListener){
                script.addEvent('readystatechange', function(){
                    if (['loaded', 'complete'].contains(this.readyState)) load.call(this);
                });
            } else {
                script.addEvent('load', load);
            }
        }

        return script.set(properties).inject(doc.head);
    },

    css: function(source, properties){
        if (!properties) properties = {};

        var load = properties.onload || properties.onLoad,
            doc = properties.document || document,
            timeout = properties.timeout || 3000;

        ['onload', 'onLoad', 'document'].each(function(prop){
            delete properties[prop];
        });

        var link = new Element('link', {
            type: 'text/css',
            rel: 'stylesheet',
            media: 'screen',
            href: source
        }).setProperties(properties).inject(doc.head);

        if (load){
            // based on article at http://www.yearofmoo.com/2011/03/cross-browser-stylesheet-preloading.html
            var loaded = false, retries = 0;
            var check = function(){
                var stylesheets = document.styleSheets;
                for (var i = 0; i < stylesheets.length; i++){
                    var file = stylesheets[i];
                    var owner = file.ownerNode ? file.ownerNode : file.owningElement;
                    if (owner && owner == link){
                        loaded = true;
                        return load.call(link);
                    }
                }
                retries++;
                if (!loaded && retries < timeout / 50) return setTimeout(check, 50);
            };
            setTimeout(check, 0);
        }
        return link;
    },

    image: function(source, properties){
        if (!properties) properties = {};

        var image = new Image(),
            element = document.id(image) || new Element('img');

        ['load', 'abort', 'error'].each(function(name){
            var type = 'on' + name,
                cap = 'on' + name.capitalize(),
                event = properties[type] || properties[cap] || function(){};

            delete properties[cap];
            delete properties[type];

            image[type] = function(){
                if (!image) return;
                if (!element.parentNode){
                    element.width = image.width;
                    element.height = image.height;
                }
                image = image.onload = image.onabort = image.onerror = null;
                event.delay(1, element, element);
                element.fireEvent(name, element, 1);
            };
        });

        image.src = element.src = source;
        if (image && image.complete) image.onload.delay(1);
        return element.set(properties);
    },

    images: function(sources, options){
        sources = Array.convert(sources);

        var fn = function(){},
            counter = 0;

        options = Object.merge({
            onComplete: fn,
            onProgress: fn,
            onError: fn,
            properties: {}
        }, options);

        return new Elements(sources.map(function(source, index){
            return Asset.image(source, Object.append(options.properties, {
                onload: function(){
                    counter++;
                    options.onProgress.call(this, counter, index, source);
                    if (counter == sources.length) options.onComplete();
                },
                onerror: function(){
                    counter++;
                    options.onError.call(this, counter, index, source);
                    if (counter == sources.length) options.onComplete();
                }
            }));
        }));
    }

};

})();

/*
---

script: Color.js

name: Color

description: Class for creating and manipulating colors in JavaScript. Supports HSB -> RGB Conversions and vice versa.

license: MIT-style license

authors:
  - Valerio Proietti

requires:
  - Core/Array
  - Core/String
  - Core/Number
  - Core/Hash
  - Core/Function
  - MooTools.More

provides: [Color]

...
*/

(function(){

var Color = this.Color = new Type('Color', function(color, type){
    if (arguments.length >= 3){
        type = 'rgb'; color = Array.slice(arguments, 0, 3);
    } else if (typeof color == 'string'){
        if (color.match(/rgb/)) color = color.rgbToHex().hexToRgb(true);
        else if (color.match(/hsb/)) color = color.hsbToRgb();
        else color = color.hexToRgb(true);
    }
    type = type || 'rgb';
    switch (type){
        case 'hsb':
            var old = color;
            color = color.hsbToRgb();
            color.hsb = old;
            break;
        case 'hex': color = color.hexToRgb(true); break;
    }
    color.rgb = color.slice(0, 3);
    color.hsb = color.hsb || color.rgbToHsb();
    color.hex = color.rgbToHex();
    return Object.append(color, this);
});

Color.implement({

    mix: function(){
        var colors = Array.slice(arguments);
        var alpha = (typeOf(colors.getLast()) == 'number') ? colors.pop() : 50;
        var rgb = this.slice();
        colors.each(function(color){
            color = new Color(color);
            for (var i = 0; i < 3; i++) rgb[i] = Math.round((rgb[i] / 100 * (100 - alpha)) + (color[i] / 100 * alpha));
        });
        return new Color(rgb, 'rgb');
    },

    invert: function(){
        return new Color(this.map(function(value){
            return 255 - value;
        }));
    },

    setHue: function(value){
        return new Color([value, this.hsb[1], this.hsb[2]], 'hsb');
    },

    setSaturation: function(percent){
        return new Color([this.hsb[0], percent, this.hsb[2]], 'hsb');
    },

    setBrightness: function(percent){
        return new Color([this.hsb[0], this.hsb[1], percent], 'hsb');
    }

});

this.$RGB = function(r, g, b){
    return new Color([r, g, b], 'rgb');
};

this.$HSB = function(h, s, b){
    return new Color([h, s, b], 'hsb');
};

this.$HEX = function(hex){
    return new Color(hex, 'hex');
};

Array.implement({

    rgbToHsb: function(){
        var red = this[0],
            green = this[1],
            blue = this[2],
            hue = 0,
            max = Math.max(red, green, blue),
            min = Math.min(red, green, blue),
            delta = max - min,
            brightness = max / 255,
            saturation = (max != 0) ? delta / max : 0;

        if (saturation != 0){
            var rr = (max - red) / delta;
            var gr = (max - green) / delta;
            var br = (max - blue) / delta;
            if (red == max) hue = br - gr;
            else if (green == max) hue = 2 + rr - br;
            else hue = 4 + gr - rr;
            hue /= 6;
            if (hue < 0) hue++;
        }
        return [Math.round(hue * 360), Math.round(saturation * 100), Math.round(brightness * 100)];
    },

    hsbToRgb: function(){
        var br = Math.round(this[2] / 100 * 255);
        if (this[1] == 0){
            return [br, br, br];
        } else {
            var hue = this[0] % 360;
            var f = hue % 60;
            var p = Math.round((this[2] * (100 - this[1])) / 10000 * 255);
            var q = Math.round((this[2] * (6000 - this[1] * f)) / 600000 * 255);
            var t = Math.round((this[2] * (6000 - this[1] * (60 - f))) / 600000 * 255);
            switch (Math.floor(hue / 60)){
                case 0: return [br, t, p];
                case 1: return [q, br, p];
                case 2: return [p, br, t];
                case 3: return [p, q, br];
                case 4: return [t, p, br];
                case 5: return [br, p, q];
            }
        }
        return false;
    }

});

String.implement({

    rgbToHsb: function(){
        var rgb = this.match(/\d{1,3}/g);
        return (rgb) ? rgb.rgbToHsb() : null;
    },

    hsbToRgb: function(){
        var hsb = this.match(/\d{1,3}/g);
        return (hsb) ? hsb.hsbToRgb() : null;
    }

});

})();
